"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const ts = require("typescript");
const ts_is_kind_1 = require("./ts-is-kind");
const hash_1 = require("./hash");
const minify_1 = require("./minify");
/** Detects that a node represents a styled function
 * Recognizes the following patterns:
 *
 * styled.tag
 * Component.extend
 * styled(Component)
 * styled('tag')
 * styledFunction.attrs(attributes)
*/
function isStyledFunction(node, identifiers) {
    if (ts_is_kind_1.isPropertyAccessExpression(node)) {
        if (isStyledObject(node.expression, identifiers)) {
            return true;
        }
        if (node.name.text === 'extend'
            && isValidComponent(node.expression)) {
            return true;
        }
        return false;
    }
    if (ts_is_kind_1.isCallExpression(node) && node.arguments.length === 1) {
        if (isStyledObject(node.expression, identifiers)) {
            return true;
        }
        if (isStyledAttrs(node.expression, identifiers)) {
            return true;
        }
    }
    return false;
}
function isStyledObjectIdentifier(name, { styled: styledIdentifiers = ['styled'] }) {
    return styledIdentifiers.indexOf(name) >= 0;
}
function isStyledObject(node, identifiers) {
    return node && ts_is_kind_1.isIdentifier(node) && isStyledObjectIdentifier(node.text, identifiers);
}
function isValidComponent(node) {
    return node && ts_is_kind_1.isIdentifier(node) && isValidComponentName(node.text);
}
function isLetter(ch) {
    return ch.toLowerCase() !== ch.toUpperCase();
}
function isValidTagName(name) {
    return isLetter(name[0]) && name[0] === name[0].toLowerCase();
}
function isValidComponentName(name) {
    return isLetter(name[0]) && (name[0] === name[0].toUpperCase());
}
function isStyledAttrsIdentifier(name, { attrs: attrsIdentifiers = ['attrs'] }) {
    return attrsIdentifiers.indexOf(name) >= 0;
}
function isStyledAttrs(node, identifiers) {
    return node && ts_is_kind_1.isPropertyAccessExpression(node)
        && isStyledAttrsIdentifier(node.name.text, identifiers)
        && isStyledFunction(node.expression, identifiers);
}
function isStyledKeyframesIdentifier(name, { keyframes = ['keyframes'] }) {
    return keyframes.indexOf(name) >= 0;
}
function isStyledCssIdentifier(name, { css = ['css'] }) {
    return css.indexOf(name) >= 0;
}
function isStyledCreateGlobalStyleIdentifier(name, { createGlobalStyle = ['createGlobalStyle'] }) {
    return createGlobalStyle.indexOf(name) >= 0;
}
function isMinifyableStyledFunction(node, identifiers) {
    return isStyledFunction(node, identifiers)
        || (ts_is_kind_1.isIdentifier(node)
            && (isStyledKeyframesIdentifier(node.text, identifiers)
                || isStyledCssIdentifier(node.text, identifiers)
                || isStyledCreateGlobalStyleIdentifier(node.text, identifiers)));
}
function defaultGetDisplayName(filename, bindingName) {
    return bindingName;
}
function createTransformer({ getDisplayName = defaultGetDisplayName, identifiers = {}, ssr = true, displayName = true, minify = false } = {}) {
    /**
     * Infers display name of a styled component.
     * Recognizes the following patterns:
     *
     * (const|var|let) ComponentName = styled...
     * export default styled...
    */
    function getDisplayNameFromNode(node) {
        if (ts_is_kind_1.isVariableDeclaration(node) && ts_is_kind_1.isIdentifier(node.name)) {
            return getDisplayName(node.getSourceFile().fileName, node.name.text);
        }
        if (ts_is_kind_1.isExportAssignment(node)) {
            return getDisplayName(node.getSourceFile().fileName, undefined);
        }
        return undefined;
    }
    function getIdFromNode(node, sourceRoot, position) {
        if ((ts_is_kind_1.isVariableDeclaration(node) && ts_is_kind_1.isIdentifier(node.name)) || ts_is_kind_1.isExportAssignment(node)) {
            const fileName = node.getSourceFile().fileName;
            const filePath = sourceRoot ? path.relative(sourceRoot, fileName).replace(path.sep, path.posix.sep) : fileName;
            return 'sc-' + hash_1.hash(`${getDisplayNameFromNode(node)}${filePath}${position}`);
        }
        return undefined;
    }
    const transformer = (context) => {
        const { sourceRoot } = context.getCompilerOptions();
        return (node) => {
            let lastComponentPosition = 0;
            const visitor = (node) => {
                if (minify
                    && ts_is_kind_1.isTaggedTemplateExpression(node)
                    && isMinifyableStyledFunction(node.tag, identifiers)) {
                    const minifiedTemplate = minify_1.minifyTemplate(node.template);
                    if (minifiedTemplate && minifiedTemplate !== node.template) {
                        const newNode = ts.createTaggedTemplate(node.tag, node.typeArguments, minifiedTemplate);
                        newNode.parent = node.parent;
                        node = newNode;
                    }
                }
                if (node.parent
                    && (ts_is_kind_1.isTaggedTemplateExpression(node.parent) && node.parent.tag === node
                        || ts_is_kind_1.isCallExpression(node.parent))
                    && node.parent.parent
                    && ts_is_kind_1.isVariableDeclaration(node.parent.parent)
                    && isStyledFunction(node, identifiers)) {
                    const styledConfig = [];
                    if (displayName) {
                        const displayNameValue = getDisplayNameFromNode(node.parent.parent);
                        if (displayNameValue) {
                            styledConfig.push(ts.createPropertyAssignment('displayName', ts.createLiteral(displayNameValue)));
                        }
                    }
                    if (ssr) {
                        const componentId = getIdFromNode(node.parent.parent, sourceRoot, ++lastComponentPosition);
                        if (componentId) {
                            styledConfig.push(ts.createPropertyAssignment('componentId', ts.createLiteral(componentId)));
                        }
                    }
                    if (styledConfig.length > 0) {
                        return ts.createCall(ts.createPropertyAccess(node, 'withConfig'), undefined, [ts.createObjectLiteral(styledConfig)]);
                    }
                }
                ts.forEachChild(node, n => {
                    if (!n.parent)
                        n.parent = node;
                });
                return ts.visitEachChild(node, visitor, context);
            };
            return ts.visitNode(node, visitor);
        };
    };
    return transformer;
}
exports.createTransformer = createTransformer;
exports.default = createTransformer;
