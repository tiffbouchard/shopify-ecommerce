"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createUserStore;

var _rxjs = require("rxjs");

var _createActions = _interopRequireDefault(require("../utils/createActions"));

var _nanoPubsub = _interopRequireDefault(require("nano-pubsub"));

var _authenticationFetcher = _interopRequireDefault(require("part:@sanity/base/authentication-fetcher"));

var _client = _interopRequireDefault(require("part:@sanity/base/client"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable @typescript-eslint/no-use-before-define */
var userChannel = (0, _nanoPubsub.default)();
var errorChannel = (0, _nanoPubsub.default)();
var _initialFetched = false;
var _currentUser = null;
var _currentError = null;
userChannel.subscribe(val => {
  _currentUser = val;
});
errorChannel.subscribe(val => {
  _currentError = val;
});

function fetchInitial() {
  return _authenticationFetcher.default.getCurrentUser().then(user => userChannel.publish(user), err => errorChannel.publish(err));
}

function logout() {
  return _authenticationFetcher.default.logout().then(() => userChannel.publish(null), err => errorChannel.publish(err));
}

var currentUser = new _rxjs.Observable(observer => {
  if (_initialFetched) {
    var emitter = _currentError ? emitError : emitSnapshot;
    emitter(_currentError || _currentUser);
  } else {
    _initialFetched = true;
    fetchInitial();
  }

  var unsubUser = userChannel.subscribe(nextUser => emitSnapshot(nextUser));
  var unsubError = errorChannel.subscribe(err => emitError(err));

  var unsubscribe = () => {
    unsubUser();
    unsubError();
  };

  return unsubscribe;

  function emitError(error) {
    observer.next({
      type: 'error',
      error
    });
  }

  function emitSnapshot(user) {
    observer.next({
      type: 'snapshot',
      user
    });
  }
});
var userCache = {};

var getUser = id => {
  if (!userCache[id]) {
    userCache[id] = _client.default.request({
      uri: "/users/".concat(id),
      withCredentials: true
    }).then(user => {
      return user && user.id ? user : null;
    });
  }

  return userCache[id];
}; // TODO Optimize for getting all users in one query


var getUsers = ids => {
  return Promise.all(ids.map(id => getUser(id)));
};

function createUserStore() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return {
    actions: (0, _createActions.default)({
      logout,
      retry: fetchInitial
    }),
    currentUser,
    getUser,
    getUsers
  };
}