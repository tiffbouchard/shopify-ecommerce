"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sumBy2 = _interopRequireDefault(require("lodash/sumBy"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _splitController = _interopRequireDefault(require("part:@sanity/components/panes/split-controller"));

var _splitPaneWrapper = _interopRequireDefault(require("part:@sanity/components/panes/split-pane-wrapper"));

var _resizeObserver = require("./resize-observer");

var _panes = require("../panes");

var _windowWidth = _interopRequireDefault(require("../utils/windowWidth"));

var _isNarrowScreen = _interopRequireDefault(require("../utils/isNarrowScreen"));

var _constants = require("../constants");

var _PaneRouterContext = require("../contexts/PaneRouterContext");

var _DeskToolPanes = _interopRequireDefault(require("./DeskToolPanes.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var COLLAPSED_WIDTH = 49;

function getPaneMinSize(pane) {
  return pane.type === 'document' ? 500 : 320;
}

function getPaneDefaultSize(pane) {
  return pane.type === 'document' ? 672 : 350;
}

function getWaitMessages(path) {
  var thresholds = [{
    ms: 300,
    message: 'Loading…'
  }, {
    ms: 5000,
    message: 'Still loading…'
  }];

  if (__DEV__) {
    var message = ['Check console for errors?', 'Is your observable/promise resolving?', path.length > 0 ? "Structure path: ".concat(path.join(' ➝ ')) : ''];
    thresholds.push({
      ms: 10000,
      message: message.join('\n')
    });
  }

  var src = (0, _rxjs.of)(null);
  return (0, _rxjs.merge)(...thresholds.map((_ref) => {
    var ms = _ref.ms,
        message = _ref.message;
    return src.pipe((0, _operators.mapTo)(message), (0, _operators.delay)(ms));
  }));
} // eslint-disable-next-line react/require-optimization


class DeskToolPanes extends _react.default.Component {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "_rootElement", /*#__PURE__*/_react.default.createRef());

    _defineProperty(this, "resizeObserver", undefined);

    _defineProperty(this, "state", {
      collapsedPanes: [],
      windowWidth: typeof window === 'undefined' ? 1000 : window.innerWidth,
      hasNarrowScreen: (0, _isNarrowScreen.default)(),
      width: undefined
    });

    _defineProperty(this, "userCollapsedPanes", []);

    _defineProperty(this, "getPaneRouterContext", (0, _PaneRouterContext.getPaneRouterContextFactory)(this));

    _defineProperty(this, "handleResize", event => {
      var width = event[0].contentRect.width;
      this.setState({
        width
      });
      this.handleAutoCollapse(width, undefined, this.userCollapsedPanes);
    });

    _defineProperty(this, "handlePaneCollapse", index => {
      if (this.state.hasNarrowScreen || this.props.panes.length === 1) {
        return;
      }

      this.userCollapsedPanes[index] = true;
      this.handleAutoCollapse(this.state.width, undefined, this.userCollapsedPanes);
    });

    _defineProperty(this, "handlePaneExpand", index => {
      if (this.state.hasNarrowScreen || this.props.panes.length === 1) {
        return;
      }

      this.userCollapsedPanes[index] = false;
      this.handleAutoCollapse(this.state.width, index, this.userCollapsedPanes);
    });

    _defineProperty(this, "handleAutoCollapse", function (width, paneWantExpand) {
      var userCollapsedPanes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var _this$props = _this.props,
          autoCollapse = _this$props.autoCollapse,
          panes = _this$props.panes;
      var hasNarrowScreen = _this.state.hasNarrowScreen;
      var paneToForceExpand = typeof paneWantExpand === 'number' ? paneWantExpand : panes.length - 1;

      if (hasNarrowScreen || !autoCollapse || !panes || panes.length === 0) {
        return;
      }

      var autoCollapsedPanes = [];
      var totalMinSize = (0, _sumBy2.default)(panes, pane => getPaneMinSize(pane));
      var remainingMinSize = totalMinSize;
      remainingMinSize -= getPaneMinSize(panes[paneToForceExpand]);
      autoCollapsedPanes[paneToForceExpand] = false;
      userCollapsedPanes[paneToForceExpand] = false;

      if (totalMinSize > width) {
        panes.forEach((pane, i) => {
          if (paneToForceExpand != i) {
            if (remainingMinSize > width - getPaneMinSize(panes[paneToForceExpand])) {
              autoCollapsedPanes[i] = true;
              remainingMinSize -= getPaneMinSize(pane) - COLLAPSED_WIDTH;
            }
          }
        });
      } // Respect userCollapsed before autoCollapsed


      var collapsedPanes = panes.map((pane, i) => userCollapsedPanes[i] || autoCollapsedPanes[i]);

      _this.setState({
        collapsedPanes
      });
    });
  }

  componentDidUpdate(prevProps) {
    if (this.props.panes.length !== prevProps.panes.length) {
      this.userCollapsedPanes = [];
      this.handleAutoCollapse(this.state.width, undefined, this.userCollapsedPanes);
    } // Expand new panes


    var paneToForceExpand = this.props.panes.reduce((acc, pane, i) => {
      return prevProps.panes[i] === pane ? acc : i;
    }, undefined);

    if (typeof paneToForceExpand !== 'undefined') {
      this.handleAutoCollapse(this.state.width, paneToForceExpand, this.userCollapsedPanes);
    }
  }

  componentDidMount() {
    var _this$props2 = this.props,
        autoCollapse = _this$props2.autoCollapse,
        panes = _this$props2.panes;

    if (autoCollapse) {
      this.resizeSubscriber = _windowWidth.default.pipe((0, _operators.distinctUntilChanged)()).subscribe(windowWidth => {
        this.setState({
          windowWidth,
          hasNarrowScreen: (0, _isNarrowScreen.default)()
        });
      });
      this.resizeObserver = new _resizeObserver.ResizeObserver(this.handleResize);

      if (this._rootElement && this._rootElement.current) {
        this.resizeObserver.observe(this._rootElement.current);
      }

      if (this.state.width) {
        this.handleAutoCollapse(this.state.width, panes.length - 1, this.userCollapsedPanes);
      }
    }
  }

  componentWillUnmount() {
    if (this.resizeObserver && this._rootElement && this._rootElement.current) {
      this.resizeObserver.unobserve(this._rootElement.current);
    }
  }

  renderPanes() {
    var _this$props3 = this.props,
        panes = _this$props3.panes,
        groupIndexes = _this$props3.groupIndexes,
        keys = _this$props3.keys,
        router = _this$props3.router;
    var routerPanes = router.state.panes;
    var hasNarrowScreen = this.state.hasNarrowScreen;
    var path = [];
    var paneKeys = ['root'].concat(keys);
    var paneGroups = [[{
      id: 'root'
    }]].concat(routerPanes || []);
    var i = -1;
    return paneGroups.reduce((components, group, index) => {
      return components.concat( // eslint-disable-next-line complexity
      group.map((sibling, siblingIndex) => {
        var groupRoot = group[0];
        var isDuplicate = siblingIndex > 0 && sibling.id === groupRoot.id;
        var pane = panes[++i];

        if (!pane) {
          return null;
        }

        var isCollapsed = Boolean(!hasNarrowScreen && this.state.collapsedPanes[i]);
        var paneKey = "".concat(i, "-").concat(paneKeys[i] || 'root', "-").concat(groupIndexes[i - 1]);
        var itemId = paneKeys[i];
        var childItemId = paneKeys[i + 1] || ''; // Same pane might appear multiple times, so use index as tiebreaker

        var wrapperKey = pane === _constants.LOADING_PANE ? "loading-".concat(i) : "".concat(i, "-").concat(pane.id);
        path.push(pane.id || "[".concat(i, "]"));

        var _ref2 = groupRoot.params || {},
            rootView = _ref2.view,
            rootParams = _objectWithoutProperties(_ref2, ["view"]);

        var params = isDuplicate ? _objectSpread(_objectSpread({}, rootParams), sibling.params) : sibling.params;
        var payload = isDuplicate ? sibling.payload || groupRoot.payload : sibling.payload;
        var paneRouterContext = this.getPaneRouterContext({
          groupIndex: index - 1,
          siblingIndex,
          flatIndex: i,
          params,
          payload
        });
        return /*#__PURE__*/_react.default.createElement(_splitPaneWrapper.default, {
          key: wrapperKey,
          isCollapsed: isCollapsed,
          minSize: getPaneMinSize(pane),
          defaultSize: getPaneDefaultSize(pane)
        }, /*#__PURE__*/_react.default.createElement(_PaneRouterContext.PaneRouterContext.Provider, {
          value: paneRouterContext
        }, pane === _constants.LOADING_PANE ? /*#__PURE__*/_react.default.createElement(_panes.LoadingPane, {
          key: paneKey // Use key to force rerendering pane on ID change
          ,
          path: path,
          index: i,
          message: getWaitMessages,
          onExpand: this.handlePaneExpand,
          onCollapse: this.handlePaneCollapse,
          isCollapsed: isCollapsed,
          isSelected: i === panes.length - 1
        }) : /*#__PURE__*/_react.default.createElement(_panes.DeskToolPane, _extends({
          key: paneKey // Use key to force rerendering pane on ID change
          ,
          paneKey: paneKey,
          index: i,
          itemId: itemId,
          urlParams: params,
          childItemId: childItemId,
          onExpand: this.handlePaneExpand,
          onCollapse: this.handlePaneCollapse,
          isCollapsed: isCollapsed,
          isSelected: i === panes.length - 1,
          isClosable: siblingIndex > 0
        }, pane))));
      }));
    }, []);
  }

  render() {
    var hasNarrowScreen = this.state.hasNarrowScreen;
    return /*#__PURE__*/_react.default.createElement("div", {
      ref: this._rootElement,
      className: _DeskToolPanes.default.root
    }, /*#__PURE__*/_react.default.createElement(_splitController.default, {
      isMobile: hasNarrowScreen,
      autoCollapse: this.props.autoCollapse,
      collapsedWidth: COLLAPSED_WIDTH,
      onCheckCollapse: this.handleCheckCollapse
    }, this.renderPanes()));
  }

}

exports.default = DeskToolPanes;

_defineProperty(DeskToolPanes, "propTypes", {
  keys: _propTypes.default.arrayOf(_propTypes.default.string).isRequired,
  groupIndexes: _propTypes.default.arrayOf(_propTypes.default.number).isRequired,
  autoCollapse: _propTypes.default.bool,
  panes: _propTypes.default.arrayOf(_propTypes.default.oneOfType([_propTypes.default.shape({
    id: _propTypes.default.string.isRequired,
    params: _propTypes.default.object
  }), _propTypes.default.symbol])).isRequired,
  router: _propTypes.default.shape({
    navigate: _propTypes.default.func.isRequired,
    navigateIntent: _propTypes.default.func.isRequired,
    state: _propTypes.default.shape({
      panes: _propTypes.default.arrayOf(_propTypes.default.arrayOf(_propTypes.default.shape({
        id: _propTypes.default.string.isRequired,
        params: _propTypes.default.object
      }))),
      payload: _propTypes.default.object,
      params: _propTypes.default.object
    })
  }).isRequired
});

_defineProperty(DeskToolPanes, "defaultProps", {
  autoCollapse: false
});