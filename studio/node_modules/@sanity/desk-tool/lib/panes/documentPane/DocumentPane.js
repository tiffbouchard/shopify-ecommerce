"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _classnames = _interopRequireDefault(require("classnames"));

var _react = _interopRequireDefault(require("react"));

var _dateFns = require("date-fns");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _schema = _interopRequireDefault(require("part:@sanity/base/schema"));

var _default = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _preview = require("part:@sanity/base/preview");

var _spinner = _interopRequireDefault(require("part:@sanity/components/loading/spinner"));

var _history = _interopRequireDefault(require("part:@sanity/base/datastore/history"));

var _tabbed = _interopRequireDefault(require("part:@sanity/components/panes/tabbed"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/snackbar/default"));

var _draftUtils = require("part:@sanity/base/util/draft-utils");

var _UseState = _interopRequireDefault(require("../../utils/UseState"));

var _InspectView = _interopRequireDefault(require("./InspectView"));

var _InspectHistory = _interopRequireDefault(require("./InspectHistory"));

var _DocumentStatusBar = require("./DocumentStatusBar");

var _Delay = _interopRequireDefault(require("../../utils/Delay"));

var _isNarrowScreen = _interopRequireDefault(require("../../utils/isNarrowScreen"));

var _windowWidth = _interopRequireDefault(require("../../utils/windowWidth"));

var _History = _interopRequireDefault(require("./History"));

var _FormView = _interopRequireDefault(require("./editor/FormView"));

var _history2 = require("./editor/history");

var _documentPaneMenuItems = require("./documentPaneMenuItems");

var _PaneRouterContext = require("../../contexts/PaneRouterContext");

var _DocumentActionShortcuts = require("./DocumentActionShortcuts");

var _Validation = require("./Validation");

var _languageSelectComponent = _interopRequireDefault(require("part:@sanity/desk-tool/language-select-component?"));

var _DocumentOperationResults = require("./DocumentOperationResults");

var PathUtils = _interopRequireWildcard(require("@sanity/util/paths"));

var _DocumentPane = _interopRequireDefault(require("./DocumentPane.css"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var styles = _DocumentPane.default;
var DEBUG_HISTORY_TRANSITION = false;
var CURRENT_REVISION_FLAG = '-';
var KEY_I = 73;
var KEY_O = 79;

function debugHistory() {
  if (DEBUG_HISTORY_TRANSITION) {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var logLine = typeof args[0] === 'string' ? "[HISTORY] ".concat(args[0]) : '[HISTORY] '; // eslint-disable-next-line no-console

    console.log(logLine, ...args.slice(1));
  }
}

function isInspectHotkey(event) {
  return event.ctrlKey && event.keyCode === KEY_I && event.altKey && !event.shiftKey;
}

function isPreviewHotkey(event) {
  return event.ctrlKey && event.keyCode === KEY_O && event.altKey && !event.shiftKey;
}

var INITIAL_HISTORICAL_DOCUMENT_STATE = {
  isLoading: false,
  snapshot: null,
  prevSnapshot: null
};
var INITIAL_HISTORY_STATE = {
  isEnabled: (0, _history2.historyIsEnabled)(),
  isLoading: true,
  error: null,
  events: []
};
var INITIAL_STATE = {
  isMenuOpen: false,
  hasNarrowScreen: (0, _isNarrowScreen.default)(),
  inspect: false,
  showValidationTooltip: false,
  historical: INITIAL_HISTORICAL_DOCUMENT_STATE,
  historyState: INITIAL_HISTORY_STATE,
  history: {}
};
var DEFAULT_MARGINS = [0, 0, 0, 0];
var MARGINS_NARROW_SCREEN_WITH_TABS = [74, 0, 64, 0];
var MARGINS_NARROW_SCREEN_WITHOUT_TABS = [53, 0, 64, 0];

class DocumentPane extends _react.default.PureComponent {
  constructor(props, _context) {
    var _this;

    super(props);
    _this = this;

    _defineProperty(this, "_historyEventsSubscription", void 0);

    _defineProperty(this, "_historyFetchDocSubscription", void 0);

    _defineProperty(this, "resizeSubscriber", void 0);

    _defineProperty(this, "_isMounted", void 0);

    _defineProperty(this, "subscription", void 0);

    _defineProperty(this, "state", _objectSpread(_objectSpread({}, INITIAL_STATE), {}, {
      hasNarrowScreen: (0, _isNarrowScreen.default)()
    }));

    _defineProperty(this, "formRef", /*#__PURE__*/_react.default.createRef());

    _defineProperty(this, "handleHistorySelect", event => {
      var paneContext = this.context;
      var eventisCurrent = this.state.history.events[0] === event;
      paneContext.setParams(_objectSpread(_objectSpread({}, paneContext.params), {}, {
        rev: eventisCurrent ? CURRENT_REVISION_FLAG : event.rev
      }), {
        recurseIfInherited: true
      });
    });

    _defineProperty(this, "handleSplitPane", () => {
      this.context.duplicateCurrent();
    });

    _defineProperty(this, "handleSetActiveView", function () {
      _this.context.setView(...arguments);
    });

    _defineProperty(this, "handleClosePane", () => {
      this.context.closeCurrent();
    });

    _defineProperty(this, "handleToggleInspect", () => {
      var value = this.props.value;

      if (!value) {
        return;
      }

      this.setState(prevState => ({
        inspect: !prevState.inspect
      }));
    });

    _defineProperty(this, "handleKeyUp", event => {
      if (event.keyCode === 'Escape' && this.state.showValidationTooltip) {
        return this.setState({
          showValidationTooltip: false
        });
      }

      if (isInspectHotkey(event) && !this.historyIsOpen()) {
        return this.handleToggleInspect();
      }

      if (isPreviewHotkey(event)) {
        //todo
        var _this$props = this.props,
            draft = _this$props.draft,
            published = _this$props.published;
        var item = (0, _documentPaneMenuItems.getProductionPreviewItem)({
          draft,
          published
        });
        return item && item.url && window.open(item.url);
      }

      return null;
    });

    _defineProperty(this, "handleHideInspector", () => {
      this.setState({
        inspect: false
      });
    });

    _defineProperty(this, "handleMenuAction", item => {
      if (item.action === 'production-preview') {
        window.open(item.url);
        return true;
      }

      if (item.action === 'inspect') {
        this.setState({
          inspect: true
        });
        return true;
      }

      if (item.action === 'browseHistory') {
        this.handleOpenHistory();
        return true;
      }

      this.setState({
        isMenuOpen: false
      });
      return false;
    });

    _defineProperty(this, "handleCloseValidationResults", () => {
      this.setState({
        showValidationTooltip: false
      });
    });

    _defineProperty(this, "handleToggleValidationResults", () => {
      this.setState(prevState => ({
        showValidationTooltip: !prevState.showValidationTooltip
      }));
    });

    _defineProperty(this, "setHistoryState", function (nextHistoryState) {
      var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _noop2.default;

      _this.setState((_ref) => {
        var currentHistoryState = _ref.historyState;
        return {
          historyState: _objectSpread(_objectSpread({}, currentHistoryState), nextHistoryState)
        };
      }, cb);
    });

    _defineProperty(this, "handleOpenHistory", () => {
      if (!this.canShowHistoryList() || this.historyIsOpen()) {
        return;
      }

      this.context.setParams(_objectSpread(_objectSpread({}, this.context.params), {}, {
        rev: CURRENT_REVISION_FLAG
      }), {
        recurseIfInherited: true
      });
    });

    _defineProperty(this, "handleCloseHistory", ctx => {
      var context = this.context || ctx;

      if (this._historyEventsSubscription) {
        this._historyEventsSubscription.unsubscribe();
      }

      var _context$params = context.params,
          rev = _context$params.rev,
          params = _objectWithoutProperties(_context$params, ["rev"]);

      if (rev) {
        // If there is a revision in the URL, remove it and let componentDidUpdate handle closing transition
        context.setParams(params, {
          recurseIfInherited: true
        });
      }
    });

    _defineProperty(this, "handleMenuToggle", evt => {
      evt.stopPropagation();
      this.setState(prevState => ({
        isMenuOpen: !prevState.isMenuOpen
      }));
    });

    _defineProperty(this, "handleEditAsActualType", () => {
      var paneContext = this.context;
      var value = this.props.value;

      if (!value) {
        throw new Error("Can't navigate to unknown document");
      }

      paneContext.navigateIntent('edit', {
        id: (0, _draftUtils.getPublishedId)(value._id),
        type: value._type
      });
    });

    _defineProperty(this, "handleSetFocus", path => {
      if (this.formRef.current) {
        this.formRef.current.handleFocus(path);
      }
    });

    _defineProperty(this, "renderActions", () => {
      var _this$props2 = this.props,
          options = _this$props2.options,
          markers = _this$props2.markers;
      var showValidationTooltip = this.state.showValidationTooltip;

      if (this.historyIsOpen()) {
        return null;
      }

      return [_languageSelectComponent.default && /*#__PURE__*/_react.default.createElement(_languageSelectComponent.default, {
        key: "language-filter"
      }), /*#__PURE__*/_react.default.createElement(_Validation.Validation, {
        id: options.id,
        key: "validation-menu",
        type: options.type,
        markers: markers,
        showValidationTooltip: showValidationTooltip,
        onCloseValidationResults: this.handleCloseValidationResults,
        onToggleValidationResults: this.handleToggleValidationResults,
        onFocus: this.handleSetFocus
      })];
    });

    _defineProperty(this, "renderHistoryFooter", selectedEvent => {
      var events = this.state.historyState.events;
      var options = this.props.options;
      return /*#__PURE__*/_react.default.createElement(_DocumentStatusBar.HistoryStatusBar, {
        id: options.id,
        type: options.type,
        selectedEvent: selectedEvent,
        isLatestEvent: events[0] === selectedEvent
      });
    });

    _defineProperty(this, "renderFooter", () => {
      var _this$props3 = this.props,
          initialValue = _this$props3.initialValue,
          options = _this$props3.options;
      var value = this.props.value || initialValue;
      return /*#__PURE__*/_react.default.createElement(_DocumentStatusBar.DocumentStatusBar, {
        id: options.id,
        type: options.type,
        lastUpdated: value && value._updatedAt,
        onLastUpdatedButtonClick: this.handleOpenHistory
      });
    });

    this.setup(props.options.id, _context);
  }

  setup(documentId, context) {
    this.dispose();

    if (this.props.urlParams.rev) {
      if ((0, _history2.historyIsEnabled)()) {
        this.handleFetchHistoricalDocument();
      } else {
        this.handleCloseHistory(context);
      }
    }
  }

  getActiveViewId() {
    var views = this.props.views;
    return this.context.params.view || views[0] && views[0].id;
  }

  getDraftId() {
    return (0, _draftUtils.getDraftId)(this.props.options.id);
  }

  getPublishedId() {
    return (0, _draftUtils.getPublishedId)(this.props.options.id);
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevProps.options.id !== this.props.options.id) {
      this.setup(this.props.options.id);
    }

    this.handleHistoryTransition(prevProps, prevState);
  }

  handleHistoryTransition(prevProps, prevState) {
    var next = this.props.urlParams;
    var prev = prevProps.urlParams;
    var selectedRev = next.rev;
    var revChanged = next.rev !== prev.rev;

    var rev = next.rev,
        params = _objectWithoutProperties(next, ["rev"]);

    var historyEvents = this.state.historyState.events;
    var historicalSnapshot = this.state.historical.snapshot;
    var isLoadingSnapshot = this.state.historical.isLoading;
    var shouldLoadHistoricalSnapshot = revChanged || !isLoadingSnapshot && selectedRev && !historicalSnapshot;
    var shouldLoadHistory = Boolean(historyEvents.length === 0 && selectedRev);

    if (prevState.historyState.isEnabled && !this.state.historyState.isEnabled) {
      this.handleCloseHistory();
    }

    if (shouldLoadHistory) {
      debugHistory('Fetch history events');
      this.handleFetchHistoryEvents();
    } // A new revision was selected, and we're not currently loading the snapshot


    if (shouldLoadHistoricalSnapshot) {
      this.handleFetchHistoricalDocument(rev);
    } // Transitioned to a different document


    if (rev && prevProps.options.id !== this.props.options.id) {
      debugHistory('Document ID changed, remove revision from URL'); // Tear out the revision from the URL, as well as the selected revision

      this.context.setParams(params, {
        recurseIfInherited: true
      });
      return;
    } // History was closed


    if (!rev && prev.rev) {
      debugHistory('History closed, reset history state');
      this.setHistoryState(INITIAL_HISTORY_STATE);
      this.setState({
        historical: INITIAL_HISTORICAL_DOCUMENT_STATE
      });
    }
  }

  handleFetchHistoricalDocument(atRev) {
    var isCurrent = atRev === CURRENT_REVISION_FLAG;

    if (isCurrent) {
      return;
    }

    var event = atRev ? this.findHistoryEventByRev(atRev) : this.findSelectedHistoryEvent();

    if (!event) {
      debugHistory('Could not find history event %s', atRev ? "for revision ".concat(atRev) : ' (selected)');
      return;
    }

    if (this._historyFetchDocSubscription) {
      this._historyFetchDocSubscription.unsubscribe();
    }

    this.setState((_ref2) => {
      var historical = _ref2.historical;
      return {
        historical: _objectSpread(_objectSpread({}, historical), {}, {
          snapshot: null,
          prevSnapshot: historical.snapshot || historical.prevSnapshot,
          isLoading: true
        })
      };
    });
    var id = event.displayDocumentId,
        rev = event.rev;
    debugHistory('Fetch historical document for rev %s', atRev);
    this._historyFetchDocSubscription = (0, _rxjs.from)(_history.default.getDocumentAtRevision(id, rev)).subscribe(newSnapshot => {
      this.setState((_ref3) => {
        var historical = _ref3.historical;
        return {
          historical: _objectSpread(_objectSpread({}, historical), {}, {
            isLoading: false,
            snapshot: newSnapshot,
            prevSnapshot: null
          })
        };
      });
    });
  }

  getInitialValue() {
    var value = this.props.value;
    var typeName = this.props.options.type;
    var base = {
      _type: typeName
    };
    return value ? base : _objectSpread(_objectSpread({}, base), this.props.initialValue);
  }

  canShowHistoryList() {
    return this.context.siblingIndex === 0 && !this.props.isCollapsed && this.state.historyState.isEnabled;
  }

  componentDidMount() {
    this._isMounted = true;

    if (this.props.urlParams.path) {// todo
      //  We don't want to keep the initial path param in the url (and the path param doesn't update according to user focus)
      //  However, uncommenting the following line in order to "clear" the param from the url causes all of the panes to
      //  be reloaded. We need to look into why this happens.
      //  this.context.setParams(omit(this.context.params, 'path'))
    }

    this.resizeSubscriber = _windowWidth.default.subscribe(() => {
      var historyEnabled = (0, _history2.historyIsEnabled)();
      var hasNarrowScreen = (0, _isNarrowScreen.default)();

      if (this.state.historyState.isEnabled !== historyEnabled) {
        this.setHistoryState({
          isEnabled: historyEnabled
        });
      }

      if (this.state.hasNarrowScreen !== hasNarrowScreen) {
        this.setState({
          hasNarrowScreen
        });
      }
    });
  }

  componentWillUnmount() {
    this._isMounted = false;

    if (this.resizeSubscriber) {
      this.resizeSubscriber.unsubscribe();
    }

    this.dispose();
  }

  isLiveEditEnabled() {
    var selectedSchemaType = _schema.default.get(this.props.options.type);

    return selectedSchemaType.liveEdit === true;
  }

  historyIsOpen() {
    return Boolean(this.props.urlParams.rev);
  }

  getInitialFocusPath() {
    var urlParams = this.props.urlParams;
    return urlParams.path ? PathUtils.fromString(urlParams.path) : null;
  }

  dispose() {
    if (this.subscription) {
      this.subscription.unsubscribe();
      this.subscription = undefined;
    }

    if (this._historyEventsSubscription) {
      this._historyEventsSubscription.unsubscribe();
    }

    if (this._historyFetchDocSubscription) {
      this._historyFetchDocSubscription.unsubscribe();
    }
  }

  handleFetchHistoryEvents() {
    var options = this.props.options;

    if (this._historyEventsSubscription) {
      this._historyEventsSubscription.unsubscribe();
    }

    this._historyEventsSubscription = _history.default.historyEventsFor((0, _draftUtils.getPublishedId)(options.id)).pipe((0, _operators.map)(events => {
      this.setHistoryState({
        events,
        isLoading: false
      });
      return events;
    })).subscribe();
  }

  renderError(error) {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: styles.error
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.errorInner
    }, /*#__PURE__*/_react.default.createElement("h3", null, "We\u2019re sorry, but your changes could not be applied."), /*#__PURE__*/_react.default.createElement(_UseState.default, {
      startWith: false
    }, (_ref4) => {
      var _ref5 = _slicedToArray(_ref4, 2),
          isExpanded = _ref5[0],
          setExpanded = _ref5[1];

      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_default.default, {
        onClick: () => this.setup(this.props.options.id)
      }, "Reload"), /*#__PURE__*/_react.default.createElement(_default.default, {
        inverted: true,
        onClick: () => setExpanded(!isExpanded)
      }, isExpanded ? 'Hide' : 'Show', " details"), /*#__PURE__*/_react.default.createElement("div", null, isExpanded && /*#__PURE__*/_react.default.createElement("textarea", {
        className: styles.errorDetails,
        onFocus: e => e.currentTarget.select(),
        value: error.stack
      })));
    })));
  }

  renderUnknownSchemaType() {
    var options = this.props.options;
    var value = this.props.value;
    var typeName = options.type;
    return /*#__PURE__*/_react.default.createElement("div", {
      className: styles.unknownSchemaType
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.unknownSchemaTypeInner
    }, /*#__PURE__*/_react.default.createElement("h3", null, "Unknown schema type"), typeName && /*#__PURE__*/_react.default.createElement("p", null, "This document has the schema type ", /*#__PURE__*/_react.default.createElement("code", null, typeName), ", which is not defined as a type in the local content studio schema."), !typeName && /*#__PURE__*/_react.default.createElement("p", null, "This document does not exist, and no schema type was specified for it."), __DEV__ && value && /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("h4", null, "Here is the JSON representation of the document:"), /*#__PURE__*/_react.default.createElement("pre", null, /*#__PURE__*/_react.default.createElement("code", null, JSON.stringify(value, null, 2))))));
  }

  getTitle(value) {
    var _this$props4 = this.props,
        paneTitle = _this$props4.title,
        options = _this$props4.options;
    var typeName = options.type;

    var type = _schema.default.get(typeName);

    if (paneTitle) {
      return /*#__PURE__*/_react.default.createElement("span", null, paneTitle);
    }

    if (this.historyIsOpen()) {
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "History of", ' ', /*#__PURE__*/_react.default.createElement(_preview.PreviewFields, {
        document: value,
        type: type,
        fields: ['title']
      }, (_ref6) => {
        var title = _ref6.title;
        return title ? /*#__PURE__*/_react.default.createElement("em", null, title) : /*#__PURE__*/_react.default.createElement("em", null, "Untitled");
      }));
    }

    if (!value) {
      return "New ".concat(type.title || type.name);
    }

    return /*#__PURE__*/_react.default.createElement(_preview.PreviewFields, {
      document: value,
      type: type,
      fields: ['title']
    }, (_ref7) => {
      var title = _ref7.title;
      return title ? /*#__PURE__*/_react.default.createElement("span", null, title) : /*#__PURE__*/_react.default.createElement("em", null, "Untitled");
    });
  }

  findSelectedHistoryEvent() {
    var selectedRev = this.props.urlParams.rev;
    return this.findHistoryEventByRev(selectedRev);
  }

  findHistoryEventByRev(rev) {
    var events = this.state.historyState.events;
    return rev === CURRENT_REVISION_FLAG ? events[0] : events.find(event => event.rev === rev || event.transactionIds.includes(rev));
  }

  getHistoryEventDateString() {
    var event = this.findSelectedHistoryEvent();
    var dateFormat = 'MMM D, YYYY, hh:mm A';
    var date = event && event.endTime;

    if (!date) {
      return '';
    }

    if ((0, _dateFns.isToday)(date)) {
      return "Today, ".concat((0, _dateFns.format)(date, 'hh:mm A'));
    }

    if ((0, _dateFns.isYesterday)(date)) {
      return "Yesterday, ".concat((0, _dateFns.format)(date, 'hh:mm A'));
    }

    return (0, _dateFns.format)(date, dateFormat);
  }

  renderHistorySpinner() {
    var isLoading = this.state.historical.isLoading;

    if (!isLoading) {
      return null;
    }

    var eventDate = this.getHistoryEventDateString();
    return /*#__PURE__*/_react.default.createElement(_Delay.default, {
      ms: 600
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: styles.spinnerContainer
    }, /*#__PURE__*/_react.default.createElement(_spinner.default, {
      center: true,
      message: "Loading revision".concat(eventDate ? " from ".concat(eventDate) : '', "\u2026")
    })));
  }

  renderCurrentView() {
    var initialValue = this.getInitialValue();
    var _this$props5 = this.props,
        views = _this$props5.views,
        options = _this$props5.options,
        urlParams = _this$props5.urlParams,
        value = _this$props5.value,
        onChange = _this$props5.onChange,
        connectionState = _this$props5.connectionState,
        markers = _this$props5.markers,
        presence = _this$props5.presence;
    var _this$state = this.state,
        isNarrowScreen = _this$state.hasNarrowScreen,
        historical = _this$state.historical,
        historyState = _this$state.historyState;
    var selectedHistoryEvent = this.findSelectedHistoryEvent();
    var typeName = options.type;

    var schemaType = _schema.default.get(typeName);

    var activeViewId = this.getActiveViewId();
    var activeView = views.find(view => view.id === activeViewId) || views[0] || {
      type: 'form'
    };
    var selectedIsLatest = urlParams.rev === CURRENT_REVISION_FLAG && selectedHistoryEvent === historyState.events[0]; // Should be null if not displaying a historical revision

    var historicalSnapshot = selectedIsLatest ? value : historical.snapshot || historical.prevSnapshot;
    var viewProps = {
      // "Documents"
      document: {
        published: value,
        draft: value,
        historical: historicalSnapshot,
        displayed: historicalSnapshot || value || initialValue
      },
      // Other stuff
      documentId: this.getPublishedId(),
      options: activeView.options,
      schemaType
    };

    var formProps = _objectSpread(_objectSpread({}, viewProps), {}, {
      value: value,
      connectionState,
      markers,
      initialFocusPath: this.getInitialFocusPath(),
      history: {
        isOpen: this.historyIsOpen(),
        selectedEvent: selectedHistoryEvent,
        isLoadingEvents: historyState.isLoading,
        isLoadingSnapshot: historical.isLoading,
        document: selectedIsLatest ? {
          isLoading: !selectedHistoryEvent,
          snapshot: value
        } : historical
      },
      presence,
      onChange
    }); // Calculate the height of the header


    var hasTabs = views.length > 1;
    var margins = isNarrowScreen ? hasTabs ? MARGINS_NARROW_SCREEN_WITH_TABS : MARGINS_NARROW_SCREEN_WITHOUT_TABS : DEFAULT_MARGINS;

    switch (activeView.type) {
      case 'form':
        return /*#__PURE__*/_react.default.createElement(_FormView.default, _extends({
          ref: this.formRef,
          id: formProps.documentId
        }, formProps, {
          margins: margins,
          isNarrowScreen: isNarrowScreen
        }));

      case 'component':
        return /*#__PURE__*/_react.default.createElement(activeView.component, viewProps);

      default:
        return null;
    }
  }

  render() {
    var _this$props6 = this.props,
        isSelected = _this$props6.isSelected,
        value = _this$props6.value,
        isCollapsed = _this$props6.isCollapsed,
        isClosable = _this$props6.isClosable,
        onCollapse = _this$props6.onCollapse,
        connectionState = _this$props6.connectionState,
        onExpand = _this$props6.onExpand,
        menuItemGroups = _this$props6.menuItemGroups,
        views = _this$props6.views,
        options = _this$props6.options,
        paneKey = _this$props6.paneKey;
    var _this$state2 = this.state,
        historical = _this$state2.historical,
        hasNarrowScreen = _this$state2.hasNarrowScreen,
        inspect = _this$state2.inspect,
        historyState = _this$state2.historyState;
    var typeName = options.type;

    var schemaType = _schema.default.get(typeName);

    if (!schemaType) {
      return this.renderUnknownSchemaType();
    }

    if (connectionState === 'connecting') {
      return /*#__PURE__*/_react.default.createElement("div", {
        className: styles.loading
      }, /*#__PURE__*/_react.default.createElement(_spinner.default, {
        center: true,
        delay: 1000,
        message: "Loading ".concat(schemaType.title, "\u2026")
      }));
    }

    var selectedHistoryEvent = this.findSelectedHistoryEvent();
    var menuItems = (0, _documentPaneMenuItems.getMenuItems)({
      value,
      isLiveEditEnabled: this.isLiveEditEnabled(),
      revision: selectedHistoryEvent && selectedHistoryEvent._rev,
      canShowHistoryList: this.canShowHistoryList()
    });
    return /*#__PURE__*/_react.default.createElement(_DocumentActionShortcuts.DocumentActionShortcuts, {
      id: options.id,
      type: typeName,
      onKeyUp: this.handleKeyUp,
      className: (0, _classnames.default)(styles.root, this.historyIsOpen() && styles.withHistory)
    }, this.historyIsOpen() && this.canShowHistoryList() && /*#__PURE__*/_react.default.createElement("div", {
      className: styles.historyContainer
    }, /*#__PURE__*/_react.default.createElement(_History.default, {
      key: "history",
      documentId: (0, _draftUtils.getPublishedId)(options.id),
      onClose: this.handleCloseHistory,
      onItemSelect: this.handleHistorySelect,
      lastEdited: value && new Date(value._updatedAt),
      events: historyState.events,
      isLoading: historyState.isLoading,
      error: historyState.error,
      selectedEvent: selectedHistoryEvent
    })), /*#__PURE__*/_react.default.createElement("div", {
      className: styles.editorContainer
    }, /*#__PURE__*/_react.default.createElement(_tabbed.default, {
      key: "pane",
      idPrefix: paneKey,
      title: this.getTitle(value),
      views: views,
      activeView: this.getActiveViewId(),
      onSetActiveView: this.handleSetActiveView,
      onSplitPane: hasNarrowScreen ? undefined : this.handleSplitPane,
      onCloseView: this.handleClosePane,
      menuItemGroups: menuItemGroups,
      isSelected: isSelected,
      isCollapsed: isCollapsed,
      onCollapse: onCollapse,
      onExpand: onExpand,
      onAction: this.handleMenuAction,
      menuItems: menuItems,
      footer: this.historyIsOpen() && selectedHistoryEvent ? this.renderHistoryFooter(selectedHistoryEvent) : this.renderFooter(),
      renderActions: this.renderActions,
      isClosable: isClosable,
      hasSiblings: this.context.hasGroupSiblings
    }, this.renderHistorySpinner(), this.renderCurrentView(), inspect && this.historyIsOpen() && historical && /*#__PURE__*/_react.default.createElement(_InspectHistory.default, {
      document: historical,
      onClose: this.handleHideInspector
    }), inspect && !this.historyIsOpen() && value && /*#__PURE__*/_react.default.createElement(_InspectView.default, {
      idPrefix: paneKey,
      value: value,
      onClose: this.handleHideInspector
    }), connectionState === 'reconnecting' && /*#__PURE__*/_react.default.createElement(_default2.default, {
      kind: "warning",
      title: "Connection lost. Reconnecting when online\u2026",
      isPersisted: true
    }), /*#__PURE__*/_react.default.createElement(_DocumentOperationResults.DocumentOperationResults, {
      id: options.id,
      type: options.type
    }))));
  }

}

exports.default = DocumentPane;

_defineProperty(DocumentPane, "contextType", _PaneRouterContext.PaneRouterContext);

_defineProperty(DocumentPane, "defaultProps", {
  title: '',
  views: [],
  menuItems: [],
  menuItemGroups: []
});