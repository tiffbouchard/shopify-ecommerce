"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.get = get;
exports.isEqual = isEqual;
exports.isSegmentEqual = isSegmentEqual;
exports.hasFocus = hasFocus;
exports.hasItemFocus = hasItemFocus;
exports.isExpanded = isExpanded;
exports.startsWith = startsWith;
exports.trimLeft = trimLeft;
exports.trimRight = trimRight;
exports.toString = toString;
exports.fromString = fromString;
exports.randomKey = randomKey;
exports.FOCUS_TERMINATOR = void 0;

var _getRandomValues = _interopRequireDefault(require("get-random-values"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reKeySegment = /_key\s*==\s*['"](.*)['"]/;
var FOCUS_TERMINATOR = '$'; // eslint-disable-next-line complexity

exports.FOCUS_TERMINATOR = FOCUS_TERMINATOR;

function get(obj, path, defaultVal) {
  var select = typeof path === 'string' ? fromString(path) : path;

  if (!Array.isArray(select)) {
    throw new Error('Path must be an array or a string');
  }

  var acc = obj;

  var _loop = function _loop(i) {
    var segment = select[i];

    if (isIndexSegment(segment)) {
      if (!Array.isArray(acc)) {
        return {
          v: defaultVal
        };
      }

      acc = acc[segment];
    }

    if (isKeySegment(segment)) {
      if (!Array.isArray(acc)) {
        return {
          v: defaultVal
        };
      }

      acc = acc.find(item => item._key === segment._key);
    }

    if (typeof segment === 'string') {
      acc = typeof acc === 'object' && acc !== null ? acc[segment] : undefined;
    }

    if (typeof acc === 'undefined') {
      return {
        v: defaultVal
      };
    }
  };

  for (var i = 0; i < select.length; i++) {
    var _ret = _loop(i);

    if (typeof _ret === "object") return _ret.v;
  }

  return acc;
}

function isEqual(path, otherPath) {
  return path.length === otherPath.length && path.every((segment, i) => isSegmentEqual(segment, otherPath[i]));
}

function isSegmentEqual(pathSegment, otherPathSegment) {
  var pathSegmentType = typeof pathSegment;
  var otherPathSegmentType = typeof otherPathSegment;

  if (pathSegmentType !== otherPathSegmentType) {
    return false;
  }

  if (pathSegmentType === 'string' || pathSegmentType === 'number') {
    return pathSegment === otherPathSegment;
  }

  if (!pathSegment || !otherPathSegment) {
    return false;
  }

  return pathSegment._key === otherPathSegment._key;
}

function hasFocus(focusPath, path) {
  var _withoutFirst = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;

  return isEqual(_withoutFirst, path);
}

function hasItemFocus(focusPath, item) {
  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);
}

function isExpanded(segment, focusPath) {
  var _focusPath = _toArray(focusPath),
      head = _focusPath[0],
      tail = _focusPath.slice(1);

  return tail.length > 0 && isSegmentEqual(segment, head);
}

function startsWith(prefix, path) {
  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]));
}

function trimLeft(prefix, path) {
  if (prefix.length === 0 || path.length === 0) {
    return path;
  }

  var _prefix = _toArray(prefix),
      prefixHead = _prefix[0],
      prefixTail = _prefix.slice(1);

  var _path = _toArray(path),
      pathHead = _path[0],
      pathTail = _path.slice(1);

  if (!isSegmentEqual(prefixHead, pathHead)) {
    return path;
  }

  return trimLeft(prefixTail, pathTail);
}

function trimRight(suffix, path) {
  var sufLen = suffix.length;
  var pathLen = path.length;

  if (sufLen === 0 || pathLen === 0) {
    return path;
  }

  var i = 0;

  while (i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1])) {
    i++;
  }

  return path.slice(0, pathLen - i);
}

function toString(path) {
  if (!Array.isArray(path)) {
    throw new Error('Path is not an array');
  }

  return path.reduce((target, segment, i) => {
    var segmentType = typeof segment;

    if (segmentType === 'number') {
      return "".concat(target, "[").concat(segment, "]");
    }

    if (segmentType === 'string') {
      var separator = i === 0 ? '' : '.';
      return "".concat(target).concat(separator).concat(segment);
    }

    if (isKeySegment(segment) && segment._key) {
      return "".concat(target, "[_key==\"").concat(segment._key, "\"]");
    }

    throw new Error("Unsupported path segment `".concat(JSON.stringify(segment), "`"));
  }, '');
}

function fromString(path) {
  if (typeof path !== 'string') {
    throw new Error('Path is not a string');
  }

  var segments = path.match(rePropName);

  if (!segments) {
    throw new Error('Invalid path string');
  }

  return segments.map(normalizePathSegment);
}

function normalizePathSegment(segment) {
  if (isIndexSegment(segment)) {
    return normalizeIndexSegment(segment);
  }

  if (isKeySegment(segment)) {
    return normalizeKeySegment(segment);
  }

  return segment;
}

function normalizeIndexSegment(segment) {
  return Number(segment.replace(/[^\d]/g, ''));
}

function normalizeKeySegment(segment) {
  var segments = segment.match(reKeySegment);
  return {
    _key: segments[1]
  };
}

function isIndexSegment(segment) {
  return typeof segment === 'number' || /^\[\d+\]$/.test(segment);
}

function isKeySegment(segment) {
  if (typeof segment === 'string') {
    return reKeySegment.test(segment.trim());
  }

  return segment && segment._key;
}

var getByteHexTable = (() => {
  var table;
  return () => {
    if (table) {
      return table;
    }

    table = [];

    for (var i = 0; i < 256; ++i) {
      table[i] = (i + 0x100).toString(16).substring(1);
    }

    return table;
  };
})(); // WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html


function whatwgRNG() {
  var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
  var rnds8 = new Uint8Array(length);
  (0, _getRandomValues.default)(rnds8);
  return rnds8;
}

function randomKey(length) {
  var table = getByteHexTable();
  return whatwgRNG(length).reduce((str, n) => str + table[n], '').slice(0, length);
}